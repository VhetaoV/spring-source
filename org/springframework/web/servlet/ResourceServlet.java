/***** Lobxxx Translate Finished ******/
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.web.servlet;

import java.io.IOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.util.AntPathMatcher;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.context.support.ServletContextResource;

/**
 * Simple servlet that can expose an internal resource, including a
 * default URL if the specified resource is not found. An alternative,
 * for example, to trying and catching exceptions when using JSP include.
 *
 * <p>A further usage of this servlet is the ability to apply last-modified
 * timestamps to quasi-static resources (typically JSPs). This can happen
 * as bridge to parameter-specified resources, or as proxy for a specific
 * target resource (or a list of specific target resources to combine).
 *
 * <p>A typical usage would map a URL like "/ResourceServlet" onto an instance
 * of this servlet, and use the "JSP include" action to include this URL,
 * with the "resource" parameter indicating the actual target path in the WAR.
 *
 * <p>The {@code defaultUrl} property can be set to the internal
 * resource path of a default URL, to be rendered when the target resource
 * is not found or not specified in the first place.
 *
 * <p>The "resource" parameter and the {@code defaultUrl} property can
 * also specify a list of target resources to combine. Those resources will be
 * included one by one to build the response. If last-modified determination
 * is active, the newest timestamp among those files will be used.
 *
 * <p>The {@code allowedResources} property can be set to a URL
 * pattern of resources that should be available via this servlet.
 * If not set, any target resource can be requested, including resources
 * in the WEB-INF directory!
 *
 * <p>If using this servlet for direct access rather than via includes,
 * the {@code contentType} property should be specified to apply a
 * proper content type. Note that a content type header in the target JSP will
 * be ignored when including the resource via a RequestDispatcher include.
 *
 * <p>To apply last-modified timestamps for the target resource, set the
 * {@code applyLastModified} property to true. This servlet will then
 * return the file timestamp of the target resource as last-modified value,
 * falling back to the startup time of this servlet if not retrievable.
 *
 * <p>Note that applying the last-modified timestamp in the above fashion
 * just makes sense if the target resource does not generate content that
 * depends on the HttpSession or cookies; it is just allowed to evaluate
 * request parameters.
 *
 * <p>A typical case for such last-modified usage is a JSP that just makes
 * minimal usage of basic means like includes or message resolution to
 * build quasi-static content. Regenerating such content on every request
 * is unnecessary; it can be cached as long as the file hasn't changed.
 *
 * <p>Note that this servlet will apply the last-modified timestamp if you
 * tell it to do so: It's your decision whether the content of the target
 * resource can be cached in such a fashion. Typical use cases are helper
 * resources that are not fronted by a controller, like JavaScript files
 * that are generated by a JSP (without depending on the HttpSession).
 *
 * <p>
 *  如果未找到指定的资源,可以暴露内部资源的简单servlet(包括默认URL)例如,使用JSP时尝试和捕获异常的替代方法包括
 * 
 * 这个servlet的进一步使用是将最后修改的时间戳应用于准静态资源(通常是JSP)。这可以作为参数指定资源的桥接,或作为特定目标资源(或列表的代理)的具体目标资源结合起来)
 * 
 *  <p>典型的用法将映射一个像"/ ResourceServlet"这样的URL到这个servlet的实例上,并使用"JSP include"操作来包含这个URL,"resource"参数指示WAR中的
 * 实际目标路径。
 * 
 *  <p> {@code defaultUrl}属性可以设置为默认URL的内部资源路径,在首次找不到或未指定目标资源时呈现
 * 
 * <p>"资源"参数和{@code defaultUrl}属性还可以指定要组合的目标资源的列表。这些资源将被逐个包含以构建响应如果上次修改的确定是活动的,则最新的时间戳记将使用这些文件
 * 
 *  <p> {@code allowedResources}属性可以设置为应该通过此servlet可用的资源的URL模式如果未设置,则可以请求任何目标资源,包括WEB-INF目录中的资源！
 * 
 *  <p>如果将此servlet用于直接访问而不是通过include,则应指定{@code contentType}属性以应用正确的内容类型请注意,当通过以下方式包含资源时,将忽略目标JSP中的内容类型头
 * RequestDispatcher包括。
 * 
 * <p>要为目标资源应用最后修改的时间戳,请将{@code applyLastModified}属性设置为true此servlet将返回目标资源的文件时间戳,作为最后修改的值,返回到此时的启动时间serv
 * let如果不可检索。
 * 
 *  请注意,如果目标资源不生成取决于HttpSession或Cookie的内容,则以上述方式应用最后修改的时间戳是有意义的;只允许评估请求参数
 * 
 *  这种最后修改的使用的典型案例是JSP,它只是简单地使用诸如包含或消息解析的基本手段来构建准静态内容在每个请求上再生这些内容是不必要的;只要文件没有更改,它就可以被缓存
 * 
 * <p>请注意,如果您告诉它,您的决定是否可以缓存目标资源的内容,这个servlet将会应用最后修改的时间戳。
 * 典型的用例是不是前端的辅助资源一个控制器,如由JSP生成的JavaScript文件(不依赖于HttpSession)。
 * 
 * 
 * @author Juergen Hoeller
 * @author Rod Johnson
 * @see #setDefaultUrl
 * @see #setAllowedResources
 * @see #setApplyLastModified
 */
@SuppressWarnings("serial")
public class ResourceServlet extends HttpServletBean {

	/**
	 * Any number of these characters are considered delimiters
	 * between multiple resource paths in a single String value.
	 * <p>
	 *  在单个String值中,这些字符的任意数量都被视为多个资源路径之间的分隔符
	 * 
	 */
	public static final String RESOURCE_URL_DELIMITERS = ",; \t\n";

	/**
	 * Name of the parameter that must contain the actual resource path.
	 * <p>
	 *  必须包含实际资源路径的参数的名称
	 * 
	 */
	public static final String RESOURCE_PARAM_NAME = "resource";


	private String defaultUrl;

	private String allowedResources;

	private String contentType;

	private boolean applyLastModified = false;

	private PathMatcher pathMatcher;

	private long startupTime;


	/**
	 * Set the URL within the current web application from which to
	 * include content if the requested path isn't found, or if none
	 * is specified in the first place.
	 * <p>If specifying multiple URLs, they will be included one by one
	 * to build the response. If last-modified determination is active,
	 * the newest timestamp among those files will be used.
	 * <p>
	 * 将当前Web应用程序中的URL设置为包含内容(如果未找到请求的路径),或者如果首先没有指定,则<p>如果指定多个URL,则将逐个包含它们以构建响应如果最后修改的确定是活动的,则将使用这些文件中的最新时间
	 * 戳。
	 * 
	 * 
	 * @see #setApplyLastModified
	 */
	public void setDefaultUrl(String defaultUrl) {
		this.defaultUrl = defaultUrl;
	}

	/**
	 * Set allowed resources as URL pattern, e.g. "/WEB-INF/res/*.jsp",
	 * The parameter can be any Ant-style pattern parsable by AntPathMatcher.
	 * <p>
	 *  将允许的资源设置为URL模式,例如"/ WEB-INF / res / * jsp",该参数可以是AntPathMatcher可解析的任何Ant样式模式
	 * 
	 * 
	 * @see org.springframework.util.AntPathMatcher
	 */
	public void setAllowedResources(String allowedResources) {
		this.allowedResources = allowedResources;
	}

	/**
	 * Set the content type of the target resource (typically a JSP).
	 * Default is none, which is appropriate when including resources.
	 * <p>For directly accessing resources, for example to leverage this
	 * servlet's last-modified support, specify a content type here.
	 * Note that a content type header in the target JSP will be ignored
	 * when including the resource via a RequestDispatcher include.
	 * <p>
	 * 设置目标资源的内容类型(通常为JSP)默认值为none,这在包含资源时适用<p>为了直接访问资源,例如利用此servlet的最新修改的支持,请在此处指定内容类型请注意,当通过RequestDispatc
	 * her包含资源包含时,目标JSP中的内容类型头将被忽略。
	 * 
	 */
	public void setContentType(String contentType) {
		this.contentType = contentType;
	}

	/**
	 * Set whether to apply the file timestamp of the target resource
	 * as last-modified value. Default is "false".
	 * <p>This is mainly intended for JSP targets that don't generate
	 * session-specific or database-driven content: Such files can be
	 * cached by the browser as long as the last-modified timestamp
	 * of the JSP file doesn't change.
	 * <p>This will only work correctly with expanded WAR files that
	 * allow access to the file timestamps. Else, the startup time
	 * of this servlet is returned.
	 * <p>
	 * 设置是否将目标资源的文件时间戳应用为最后修改的值默认为"false"<p>这主要用于不生成会话特定或数据库驱动内容的JSP目标：可以缓存这些文件只要JSP文件的最后一次修改的时间戳不会改变,只能通过浏览
	 * 器更改<p>这将只能在允许访问文件时间戳的扩展WAR文件中正常工作否则返回此servlet的启动时间。
	 * 
	 */
	public void setApplyLastModified(boolean applyLastModified) {
		this.applyLastModified = applyLastModified;
	}


	/**
	 * Remember the startup time, using no last-modified time before it.
	 * <p>
	 *  记住启动时间,使用之前没有最后修改的时间
	 * 
	 */
	@Override
	protected void initServletBean() {
		this.pathMatcher = getPathMatcher();
		this.startupTime = System.currentTimeMillis();
	}

	/**
	 * Return a PathMatcher to use for matching the "allowedResources" URL pattern.
	 * Default is AntPathMatcher.
	 * <p>
	 *  返回一个PathMatcher用于匹配"allowedResources"URL模式Default是AntPathMatcher
	 * 
	 * 
	 * @see #setAllowedResources
	 * @see org.springframework.util.AntPathMatcher
	 */
	protected PathMatcher getPathMatcher() {
		return new AntPathMatcher();
	}


	/**
	 * Determine the URL of the target resource and include it.
	 * <p>
	 *  确定目标资源的URL并将其包含
	 * 
	 * 
	 * @see #determineResourceUrl
	 */
	@Override
	protected final void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

		// determine URL of resource to include
		String resourceUrl = determineResourceUrl(request);

		if (resourceUrl != null) {
			try {
				doInclude(request, response, resourceUrl);
			}
			catch (ServletException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Failed to include content of resource [" + resourceUrl + "]", ex);
				}
				// Try including default URL if appropriate.
				if (!includeDefaultUrl(request, response)) {
					throw ex;
				}
			}
			catch (IOException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Failed to include content of resource [" + resourceUrl + "]", ex);
				}
				// Try including default URL if appropriate.
				if (!includeDefaultUrl(request, response)) {
					throw ex;
				}
			}
		}

		// no resource URL specified -> try to include default URL.
		else if (!includeDefaultUrl(request, response)) {
			throw new ServletException("No target resource URL found for request");
		}
	}

	/**
	 * Determine the URL of the target resource of this request.
	 * <p>Default implementation returns the value of the "resource" parameter.
	 * Can be overridden in subclasses.
	 * <p>
	 * 确定此请求的目标资源的URL <p>默认实现返回"resource"参数的值可以在子类中覆盖
	 * 
	 * 
	 * @param request current HTTP request
	 * @return the URL of the target resource, or {@code null} if none found
	 * @see #RESOURCE_PARAM_NAME
	 */
	protected String determineResourceUrl(HttpServletRequest request) {
		return request.getParameter(RESOURCE_PARAM_NAME);
	}

	/**
	 * Include the specified default URL, if appropriate.
	 * <p>
	 *  包括指定的默认URL(如果适用)
	 * 
	 * 
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @return whether a default URL was included
	 * @throws ServletException if thrown by the RequestDispatcher
	 * @throws IOException if thrown by the RequestDispatcher
	 */
	private boolean includeDefaultUrl(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

		if (this.defaultUrl == null) {
			return false;
		}
		doInclude(request, response, this.defaultUrl);
		return true;
	}

	/**
	 * Include the specified resource via the RequestDispatcher.
	 * <p>
	 *  通过RequestDispatcher包含指定的资源
	 * 
	 * 
	 * @param request current HTTP request
	 * @param response current HTTP response
	 * @param resourceUrl the URL of the target resource
	 * @throws ServletException if thrown by the RequestDispatcher
	 * @throws IOException if thrown by the RequestDispatcher
	 */
	private void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)
		throws ServletException, IOException {

		if (this.contentType != null) {
			response.setContentType(this.contentType);
		}
		String[] resourceUrls =
			StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);
		for (int i = 0; i < resourceUrls.length; i++) {
			// check whether URL matches allowed resources
			if (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, resourceUrls[i])) {
				throw new ServletException("Resource [" + resourceUrls[i] +
						"] does not match allowed pattern [" + this.allowedResources + "]");
			}
			if (logger.isDebugEnabled()) {
				logger.debug("Including resource [" + resourceUrls[i] + "]");
			}
			RequestDispatcher rd = request.getRequestDispatcher(resourceUrls[i]);
			rd.include(request, response);
		}
	}

	/**
	 * Return the last-modified timestamp of the file that corresponds
	 * to the target resource URL (i.e. typically the request ".jsp" file).
	 * Will simply return -1 if "applyLastModified" is false (the default).
	 * <p>Returns no last-modified date before the startup time of this servlet,
	 * to allow for message resolution etc that influences JSP contents,
	 * assuming that those background resources might have changed on restart.
	 * <p>Returns the startup time of this servlet if the file that corresponds
	 * to the target resource URL couldn't be resolved (for example, because
	 * the WAR is not expanded).
	 * <p>
	 * 返回与目标资源URL相对应的文件的最后修改的时间戳(即通常为请求"jsp"文件)。
	 * 如果"applyLastModified"为false(默认值),将简单返回-1 <p>不返回最后修改的日期在此servlet的启动时间之前,允许影响JSP内容的消息解析等,假设这些后台资源在重新启动时
	 * 可能已更改<p>如果与目标资源URL对应的文件可以返回此servlet的启动时间不能解决(例如,因为WAR未展开)。
	 * 返回与目标资源URL相对应的文件的最后修改的时间戳(即通常为请求"jsp"文件)。
	 * 
	 * @see #determineResourceUrl
	 * @see #getFileTimestamp
	 */
	@Override
	protected final long getLastModified(HttpServletRequest request) {
		if (this.applyLastModified) {
			String resourceUrl = determineResourceUrl(request);
			if (resourceUrl == null) {
				resourceUrl = this.defaultUrl;
			}
			if (resourceUrl != null) {
				String[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);
				long latestTimestamp = -1;
				for (int i = 0; i < resourceUrls.length; i++) {
					long timestamp = getFileTimestamp(resourceUrls[i]);
					if (timestamp > latestTimestamp) {
						latestTimestamp = timestamp;
					}
				}
				return (latestTimestamp > this.startupTime ? latestTimestamp : this.startupTime);
			}
		}
		return -1;
	}

	/**
	 * Return the file timestamp for the given resource.
	 * <p>
	 * 
	 * 
	 * @param resourceUrl the URL of the resource
	 * @return the file timestamp in milliseconds, or -1 if not determinable
	 */
	protected long getFileTimestamp(String resourceUrl) {
		ServletContextResource resource = new ServletContextResource(getServletContext(), resourceUrl);
		try {
			long lastModifiedTime = resource.lastModified();
			if (logger.isDebugEnabled()) {
				logger.debug("Last-modified timestamp of " + resource + " is " + lastModifiedTime);
			}
			return lastModifiedTime;
		}
		catch (IOException ex) {
			logger.warn("Couldn't retrieve last-modified timestamp of [" + resource +
					"] - using ResourceServlet startup time");
			return -1;
		}
	}

}
